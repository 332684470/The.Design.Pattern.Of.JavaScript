# 第4节-异步

## 同步与异步
同步行为对应着内存中顺序执行的处理器指令

每条指令都会严格按照他们出现的顺序执行,且执行后就能立即获得

存储在系统本地的内容和信息
例如:
```JavaScript
// 简单的同步实例
let a=1;
a=a+1;
console.log(a);//2
```
我们可以发现无论执行多少次,上方代码在输出a时,a都是2,

且我们作为阅读者在阅读代码时,也能做到判断和推断

同步的代码的确是对程序员友好的,但是在实际生活中,

代码也被设计为访问一些高延迟的资源或者一个需要大量时间运行的函数等等

比如向远程服务器发送请求并等待响应或者循环生成大量内容的代码

耗费长时间去等待显然不是最佳的方案

而异步就是更好的方案

```JavaScript
// 异步实例
let a=1;
setTimeout(()=>a++,10000);
console.log(a);//1
```
从这个异步的代码可以看出程序直到最后输出的a的值依旧为1

同时如果我们等待一定时间(大约10s),在控制台查询a的值的话,会发现它变成了2

同时我们能预想到,若是代码足够多足够复杂,我们将会失去判断和推断代码运行的能力

那么如果我们想在a改变后,知道他改变了然后才使用他,该如何去做呢

## JS中异步的发展
早期JS中,定义回调函数来表明异步操作完成

不过,若是需要用到异步操作完成后返回的值(异步操作的函数无法使用return设置返回值),

普遍的的方案是提供一个回调函数给异步操作,这个回调函数包括了需要用到返回值的代码
```javascript
function plusOne(value,callback) {
    setTimeout(
        ()=>{
            value+=1;
            callback(value);
        }
        ,1000
    );
}
plusOne(1,(value)=>{
    console.log("now the value is "+value);//2
});
```
但如果我们需要频繁多次地用到返回的值,就必须进行嵌套

同时也会发现这样的代码及其难以阅读维护和扩展,甚至看一眼都想晕过去,

即臭名昭著的回调地狱问题
```javascript
plusOne(1, (value) => {
    plusOne(value, (value) => {
        plusOne(value, (value) => {
            plusOne(value, (value) => {
                plusOne(value, (value) => {
                    plusOne(value, (value) => {
                        console.log("now the value is " + value);
                    })
                })
            })
        })
    })
})
//now the value is 7
```

## promise
promise 即目前人们经常提起的期约(一部分人称其为承诺)

promise 期约这个概念在上个世纪就已经诞生,是对尚不存在的结果的一个替身

ES6更新了Promise这个引用类型,使用new实例化,创建新期约实例时需要传入执行器函数(executor)当作参数
```javascript
let p1=new Promise(()=>{});//简单示例,传入了一个空函数
console.log(p1);//Promise {<pending>}
```

那么究竟如何理解promise

首先设想一个场景,一个售卖新款笔记本电脑的商家和一群笔电发烧友

这群笔电发烧友迫不及待地想要买到最新款的笔记本电脑,而商家手里却并没有现货可以售卖

则此时无论发烧友如何哀求,这新款笔记本都是买不到的

不过商家promise他会在到货的第一时间通知这群发烧友,则他们就能第一时间买到

```javascript
// 创建promise实例
let promise=new Promise((resolve,reject)=>{
// executor
});
传递给new Promise的函数称为executor(执行器)
当promise实例被创建时,它(执行器)会自动运行
而其中的参数resolve和reject也是回调函数
当executor执行并产生最终结果时,应当执行这两个回调函数中的一个
resolve(value)--->任务成功返回结果value
reject(error)---->执行中出现错误且返回error(error对象)
```
### promise的状态
```javascript
console.log(new Promise((resolve,reject)=>{}));//Promise {<pending>}

```
