# 第4节-异步

## 同步与异步
同步行为对应着内存中顺序执行的处理器指令

每条指令都会严格按照他们出现的顺序执行,且执行后就能立即获得

存储在系统本地的内容和信息
例如:
```JavaScript
// 简单的同步实例
let a=1;
a=a+1;
console.log(a);//2
```
我们可以发现无论执行多少次,上方代码在输出a时,a都是2,

且我们作为阅读者在阅读代码时,也能做到判断和推断

同步的代码的确是对程序员友好的,但是在实际生活中,

代码也被设计为访问一些高延迟的资源或者一个需要大量时间运行的函数等等

比如向远程服务器发送请求并等待响应或者循环生成大量内容的代码

耗费长时间去等待显然不是最佳的方案

而异步就是更好的方案

```JavaScript
// 异步实例
let a=1;
setTimeout(()=>a++,10000);
console.log(a);//1
```
从这个异步的代码可以看出程序直到最后输出的a的值依旧为1

同时如果我们等待一定时间(大约10s),在控制台查询a的值的话,会发现它变成了2

同时我们能预想到,若是代码足够多足够复杂,我们将会失去判断和推断代码运行的能力

那么如果我们想在a改变后,知道他改变了然后才使用他,该如何去做呢

## JS中异步的发展
早期JS中,定义回调函数来表明异步操作完成

不过,若是需要用到异步操作完成后返回的值(异步操作的函数无法使用return设置返回值),

普遍的的方案是提供一个回调函数给异步操作,这个回调函数包括了需要用到返回值的代码
```javascript
function plusOne(value,callback) {
    setTimeout(
        ()=>{
            value+=1;
            callback(value);
        }
        ,1000
    );
}
plusOne(1,(value)=>{
    console.log("now the value is "+value);//2
});
```
但如果我们需要频繁多次地用到返回的值,就必须进行嵌套

同时也会发现这样的代码及其难以阅读维护和扩展,甚至看一眼都想晕过去,

即臭名昭著的回调地狱问题
```javascript
plusOne(1, (value) => {
    plusOne(value, (value) => {
        plusOne(value, (value) => {
            plusOne(value, (value) => {
                plusOne(value, (value) => {
                    plusOne(value, (value) => {
                        console.log("now the value is " + value);
                    })
                })
            })
        })
    })
})
//now the value is 7
```

## promise
promise 即目前人们经常提起的期约(一部分人称其为承诺)

promise 期约这个概念在上个世纪就已经诞生,是对尚不存在的结果的一个替身

ES6更新了Promise这个引用类型,使用new实例化,创建新期约实例时需要传入执行器函数(executor)当作参数
```javascript
let p1=new Promise(()=>{});//简单示例,传入了一个空函数
console.log(p1);//Promise {<pending>}
```

那么究竟如何理解promise

首先设想一个场景,一个售卖新款笔记本电脑的商家和一群笔电发烧友

这群笔电发烧友迫不及待地想要买到最新款的笔记本电脑,而商家手里却并没有现货可以售卖

则此时无论发烧友如何哀求,这新款笔记本都是买不到的

不过商家promise他会在到货的第一时间通知这群发烧友,则他们就能第一时间买到

```javascript
// 创建promise实例
let promise=new Promise((resolve,reject)=>{
// executor
});

// 传递给new Promise的函数称为executor(执行器)
// 当promise实例被创建时,它(执行器)会自动运行
// 而其中的参数resolve和reject也是回调函数
// 当executor执行并产生最终结果时,应当执行这两个回调函数中的一个
// resolve(value)--->任务成功且带有结果value
// reject(error)---->执行中出现错误error(即error对象)
```
### promise的内部属性
```javascript
console.log(new Promise((resolve,reject)=>{}));//Promise {<pending>}
// 通过控制台查看promise实例时,可以发现两个奇特的隐藏属性
// [[PromiseState]]和[[PromiseResult]]
```

#### [[PromiseState]]与三种状态
```
promise是一个有状态的对象,可能处于三种状态,分别是
pending(待定)状态
fulfilled(兑现,有时也叫解决 resolved)
rejected(拒绝)

promise最初始状态是pending,但并非初始化实例的时候一定得是pending

在pending状态下,promise可以落定(settled)为代表成功的fulfilled状态
和代表代表失败的rejected状态,且该落定行为会且只会有一次,即状态改变后是不可变不可逆的,
故promise可以永远处于pending也可以落定为fulfilled或rejected,一旦落定就不再改变

更应知道的是,[[PromiseState]]属性是私有的,即外部无法访问到也无法进行修改,其目的是为了避免
外界的代码直接通过该属性处理了promise,甚至导致本该是异步的代码被设计成了同步代码的情况
```

#### [[PromiseResult]]
该属性的作用是存储需要的数据,最初为undefined
```
当调用resolve(value)时,即任务执行成功且带有结果value时,
[[PromiseResult]]属性会从undefined--->value

当调用reject(error)时,即执行中出现错误error(即error对象)时,
[[PromiseResult]]属性的值会从undefined--->error

```

```javascript
let promise=new Promise((resolve,reject)=>{
    // 这里假设有一段异步的业务代码(当然resolve和reject也可以立即执行)
    // 然后得到需要的value
    let value='白金之星';
    resolve(value);
    reject(new Error('世界'));
});
console.log(promise);

// Promise {<fulfilled>: '白金之星'}
// 从上方的执行结果可知,该value值被存储在了[[PromiseResult]]里,
// 且[[PromiseState]]状态也变为了fulfilled
// 再者resolve后的reject代码并未生效
// 但如果注释掉上方的resolve(value),
// 可以看到输出变为了Promise {<rejected>: Error: 世界}
// 也即是之前提到的一次落定,再不更改
```
下面再来理清一编具体的顺序

首先回想一遍,我们一般在什么情况下会使用promise---答案是异步操作

而到目前为止,我们先创建promise实例,然后假设在executor里写入了了异步操作的业务代码

最后通过传入executor的参数(resolve和reject这两个回调函数)对业务代码的最终结果进行了存储

(根据具体调用的是resolve还是reject,[[PromiseState]]改变,[[PromiseResult]]也改变)

这其实在做什么,这不正是在做买卖新款电脑故事中老板的事情吗

>首先设想一个场景,一个售卖新款笔记本电脑的商家和一群笔电发烧友......(我把电脑生产出来,然后准备卖给发烧友大赚一笔!!!)

```
对于reject(error)的调用,
可以理解为电脑在生产时出现设计缺陷,或工厂材料短缺等等一系列问题导致无法正常进行生产的情况
```

因此接下来需要考虑的就是发烧友的事情了(老板已经生产了电脑,我要下单了!!!),即访问这个value且能够操作他.

### Promise.prototype.then()与Promise.prototype.catch()
