# 第3节-闭包和高阶函数

## 闭包
闭包是JS的一个很重要的特性,想了解闭包

首先得清楚闭包的形成与变量的作用域和变量的生存周期密切相关

### 变量的作用域(var let const)
#### 老旧的var
在一些编写时间较早的JS代码中,我们经常能看到var关键字

作为早期使用的关键字,var不同于现在使用的let const关键字具有块作用域

var声明的变量的作用域是函数作用域

即当变量是由var声明且在函数内部声明

该变量就只能在函数内部访问到,外部无法访问
```Javascript
function fn(){
    var a=1;
    console.log(a);
}
fn();//1
console.log(a);//Uncaught ReferenceError: a is not defined

----------------------------------------------------
var b=2;
function fn(){
    var a=1;
    var b=3;
    console.log(a);
    console.log(b);
}
fn();//1 3
console.log(b);//2
console.log(a);//Uncaught ReferenceError: a is not defined
// 由上我们可以得出,函数作用域内部的变量,外部是无法访问到的
// 而函数内部却可以访问外部的变量,但是在变量搜索时,依然是沿着作用域链从内向外搜索,直到搜索到全局为止
```
var与立即执行函数IIFE
```JavaScript
// 在没有let和const关键字的年代,使用立即执行函数可以模拟块作用域
(function (){
    var a=1;
    console.log(a);
})();//1
console.log(a);//a is not defined
```
#### let与const
作为后加入的关键字,let和const具有块作用域,

即在该代码块里声明的变量,只能在该代码块里访问到
```javascript
{
    let a=1;
    console.log(a);//1
}
{
    let b=2;
    console.log(b);//2
}
{
    const c=3;
    console.log(c);//3
}
console.log(a);//a is not defined
console.log(b);//b is not defined
console.log(c);//c is not defined
```


### 变量生命周期
我们应该知道,对于开发者来说,JS的内存管理是自动的,

即垃圾回收是自动完成的,

而我们创建的一切东西如原始值,对象...等必然会占用内存

那么全局变量作为全局可访问的变量,必然是不会被清理的

那么局部变量是否会在函数执行结束或函数不在嵌套调用链上后被清除呢
```JavaScript
let fn1=function (){
    let a=0;
    console.log(a);
    a+=1;
}
fn1();//0
fn1();//0
fn1();//0
// 由上方代码可知,局部变量a在函数执行完后被清除了

// 下方代码是一个嵌套函数
// 如果一个函数是在另一个函数中创建的，该函数就被称为嵌套函数
let fn2=(function (){
    let a=0;
    return function(){
        a+=1;
        console.log(a);
    }
})();
fn2();//1
fn2();//2
fn2();//3
// 我们会发现这种写法下,每一次函数执行后,a的值被保留了下来
// 那么这个是如何实现的
// 我们需要了解一个东西,词法作用域
```
#### 词法作用域
1.词法环境(Lexical Environment)
```
JS中每个运行的函数,代码块以及整个脚本,都有一个被称为词法环境的

内部(隐藏)的关联对象

而词法环境由 环境记录 和 对外部词法环境的引用(与外部代码相关联) 两部

分组成

环境记录:是一个存储所有局部变量作为其属性(包括一些其他信息,例如this的
值)的对象

*词法环境只是一个存在于理论层面的语言规范产生的规范对象,无法直接通过代
码去获取他且操作他
```
2.函数声明
```
当词法环境创建完成后,函数声明会立即变为即用型函数(不同于let声明的变量直

到声明处才可用),即我们可以在声明函数前调用他

*只适用于函数声明式创建的函数
```
3.内部和外部的词法环境
```javascript
在一个函数运行时,在调用时,会自动创建一个新的词法环境存储这个调用的
局部变量和参数
let a="i am a";
function fn3(b){
    console.log(b);
    if(a){
        console.log("i can get a and it's "+a);
    }
}
fn3("i am b");//i am b
// i can get a and it's i am a

根据上方代码来看,在这个函数调用的时候,产生了两个词法环境
首先是外部的词法作用域(全局),然后是函数创建的内部词法环境
内部词法环境:当函数fn3执行时,此时的内部词法环境具有b这个属性,而我们传入
的b是字符串"i am b",引用了外部词法环境
外部词法环境:具有let声明的变量a,具有函数声明fn3,已经是全局词法环境
无对外部的引用

当我们的代码访问一个变量时,首先会搜索内部词法环境,没有就继续搜索外部环境,
直到全局词法环境
即在fn3中访问全局变量a,也即是内部词法环境引用外部词法环境
```
4.return function
```
回顾上方fn1和fn2

fn1在多次重复执行后,每一次的结果都一致
其原因是每次函数执行完,他的局部变量便会失去价值,就会被清理掉
而多次调用函数fn1,访问某变量,该变量也没有声明在外部(这里是全局变量)
而是声明在内部作为局部变量,每一次执行都会声明,完成后销毁,因而不存在记
录该值的能力

fn2是一个立即执行函数(不是IIFE也适用),返回的也是一个函数
我们应该清楚,不同于fn1,fn2的这个写法一共会创建三个词法环境
全局词法环境 立即执行函数带来的外部词法环境(相对于) 内部词法环境

所有的函数在诞生时,都会记录创建他们的词法环境:所有函数都有名为
[[Environment]]的隐藏属性,保存了对创建该函数的词法环境的引用

因此fn2记录了对a的引用

而每一次调用fn2,fn2都会创建一个新的词法环境,即上方提到的三个词法环境
中的内部词法环境,然后根据代码需要访问并操作a,尽管每一次的创建都会导致
词法环境是全新的,不过这一次是程序员获得了胜利,我们不在其内部声明变量
a,而是通过记录下来的对a存在的词法环境的引用,链式地访问到a
尽管a依旧是一个局部变量,但是只要他作为局部变量所在环境还能被外界访问
他就有了存在的理由,那就不会被销毁
```
5.天生的闭包
```
闭包:是指一个函数可以记住其外部变量并可以访问这些变量
JS中的函数会自动通过隐藏的 [[Environment]] 属性记住创建它
们的位置，所以它们都可以访问外部变量
在JS中，所有函数都是天生闭包的,除了使用new Function方法创建的函数
我们使用new Function 建一个函数,那么该函数的 [[Environment]] 并不
指向当前的词法环境,而是指向全局环境
因此,此类函数无法访问外部（outer）变量,只能访问全局变量
```




## 高阶函数
高阶函数是指以下满足其一的函数:

.函数可以作为参数传递

.函数可以作为返回值返回

### 函数作为参数传递
1.回调函数
被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数

这样可以抽离出容易变化或需要变化的内容,放在回调函数中,分离不变与变化的部分

例如:封装ajax请求,并且传入两个回调函数来动态设置成功失败两种不同的情况
(这里是回调函数在异步中的应用,回调函数不止存在于异步中)
```JavaScript
function Ajax(url, success, fail) {
    let xhr = new XMLHttpRequest();
    xhr.open('get', url);
    xhr.send();

    xhr.onreadystatechange = () => {
        if (xhr.readyState === 4 && xhr.status === 200) {
            console.log("success!");
            success && success();
        }
        else {
            console.log("error!");
            fail && fail();
        }
    }
}
// 调用,且传入回调函数success和fail
Ajax(
    "test.html",
    () => {console.log("i am callback success");},
    ()=>{console.log("i am callback fail");}
)
*回调函数有时候会造成回调地狱问题
```

2.某些内建对象的方法也需要传入回调函数实现丰富的功能

如

setTimeout()方法设置一个定时器,该定时器在定时器到期后执行一个函数或指定的一段代码

Array.prototype.sort()就可以接收一个函数当作参数,用来指定按某种顺序进行排列

### 函数作为返回值返回
让函数继续返回一个可执行的函数,达到了延续运算过程的作用

### 高阶函数与AOP
插眼---------------------------------------------------------------------------

